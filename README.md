# AofC_2022

Learning F# by doing [AdventOfCode 2022](https://adventofcode.com/2022)

Previous:
* [2021](https://github.com/JWMB/AofC_2021)


##Autogenerated##
## [Day 1 - Calorie Counting](https://adventofcode.com/2022/day/1)
[Source](/AofC_2022/Days/D1.fs) | [Input](/AofC_2022/Days/D1.txt)  
### part1
```FSharp
let part1 input =
    let result = Array.max (sums input)
    result
```
Result (in `12`ms): `71934`
### part2
```FSharp
let part2 input =
    let sorted = (sums input) |> Array.sortDescending
    let result = sorted |> Array.take 3 |> Array.sum
    result
```
Result (in `11`ms): `211447`
## [Day 2 - Rock Paper Scissors](https://adventofcode.com/2022/day/2)
[Source](/AofC_2022/Days/D2.fs) | [Input](/AofC_2022/Days/D2.txt)  
### part1
```FSharp
let part1 input =
    let rows = Parsing.parseRows input parseRow
    let results = rows |> Array.map (fun f -> getOutcome f[0] f[1])
    let sum = results |> Array.sum
    sum
```
Result (in `4`ms): `10624`
### part2
```FSharp
let part2 input =
    let rows = Parsing.parseRows input parseRow
    let results = rows |> Array.map (fun f -> (chooseItem f[0] (f[1] - 1)) + 1 + getPoints (f[1] - 1))
    let sum = results |> Array.sum
    sum
```
Result (in `12`ms): `14060`
## [Day 3 - Rucksack Reorganization](https://adventofcode.com/2022/day/3)
[Source](/AofC_2022/Days/D3.fs) | [Input](/AofC_2022/Days/D3.txt)  
### part1
```FSharp
let part1 input =
    let rucksacks = Parsing.parseRows input parseRow
    let compartmentalized = rucksacks |> Array.map (fun f -> f |> Array.splitAt (f.Length / 2))
    let samePer = compartmentalized |> Array.map (fun (a, b) -> [| a; b |] |> intersectMany)
    let sum = samePer |> flatten |> Array.sum
    sum
```
Result (in `19`ms): `7997`
### part2
```FSharp
let part2 input =
    let rucksacks = Parsing.parseRows input parseRow
    let numGroups = rucksacks.Length / 3
    let groups = rucksacks |> Array.splitInto numGroups
    let samePer = groups |> Array.map intersectMany
    let sum = samePer |> flatten |> Array.sum
    sum
```
Result (in `4`ms): `2545`
## [Day 4 - Camp Cleanup](https://adventofcode.com/2022/day/4)
[Source](/AofC_2022/Days/D4.fs) | [Input](/AofC_2022/Days/D4.txt)  
### part1
```FSharp
let part1 input =
    let pairs = Parsing.parseRows input parseRow
    let numWithCompleteOverlap = pairs |> Array.filter (fun pair -> isRangeWithin pair[0] pair[1] || isRangeWithin pair[1] pair[0]) |> Array.length
    numWithCompleteOverlap
```
Result (in `9`ms): `450`
### part2
```FSharp
let part2 input =
    let pairs = Parsing.parseRows input parseRow
    let numWithPartialOverlap = pairs |> Array.filter (fun pair -> isRangeOverlap pair[0] pair[1]) |> Array.length
    numWithPartialOverlap
```
Result (in `4`ms): `837`
## [Day 5 - Supply Stacks](https://adventofcode.com/2022/day/5)
[Source](/AofC_2022/Days/D5.fs) | [Input](/AofC_2022/Days/D5.txt)  
### part1
```FSharp
let part1 input =
    let data = ParsedInput.Parse input

    let func = Instruction.Execute true
    let modifiedStacks = foldWithFunction func data.Instructions data.Stacks

    let result = modifiedStacks |> Array.map (fun f -> f[0]) |> Array.map string |> String.concat ""
    result
```
Result (in `34`ms): `SBPQRSCDF`
### part2
```FSharp
let part2 input =
    let data = ParsedInput.Parse input

    let func = Instruction.Execute false
    let modifiedStacks = foldWithFunction func data.Instructions data.Stacks

    let result = modifiedStacks |> Array.map (fun f -> f[0]) |> Array.map string |> String.concat ""
    result
```
Result (in `13`ms): `RGLVRCQSB`
## [Day 6 - Tuning Trouble](https://adventofcode.com/2022/day/6)
[Source](/AofC_2022/Days/D6.fs) | [Input](/AofC_2022/Days/D6.txt)  
### part1
```FSharp
let part1 input =
    let markerLength = 4
    let x = Parsing.cleanWithTrimEmptyLines input
            |> stringToIndexedTuples
            |> Seq.fold (findFirstNonRepeatingStringOfLength markerLength) (0, "")

    let result = getMarkerEndIndex x markerLength
    result
```
Result (in `10`ms): `1544`
### part2
```FSharp
let part2 input =
    let markerLength = 14
    let x = Parsing.cleanWithTrimEmptyLines input
            |> stringToIndexedTuples
            |> Seq.fold (findFirstNonRepeatingStringOfLength markerLength) (0, "")

    let result = getMarkerEndIndex x markerLength
    result
```
Result (in `2`ms): `2145`
## [Day 7 - No Space Left On Device](https://adventofcode.com/2022/day/7)
[Source](/AofC_2022/Days/D7.fs) | [Input](/AofC_2022/Days/D7.txt)  
### part1
```FSharp
let part1 input =
    let hierarchy = getHierarchy input

    let dirsWithAllChildren = flattenChildren hierarchy |> Seq.toList |> List.filter (fun (f, _) -> isBranch f) |> List.map (fun (f, size) -> (getItemFromNode f, size))

    let sizes = dirsWithAllChildren |> List.map (fun (f, children) -> (f, children |> List.sumBy (fun f -> f.size)))
                    |> List.map (fun (_, size) -> size)
    let sum = sizes |> List.filter (fun size -> size <= 100000) |> List.sum
    sum
```
Result (in `214`ms): `2061777`
### part2
```FSharp
let part2 input =
    let maxSpace = 70000000
    let needed = 30000000
    let maxForExistingStructure = maxSpace - needed

    let hierarchy = getHierarchy input

    let dirsWithAllChildren = flattenChildren hierarchy |> Seq.toList |> List.filter (fun (f, _) -> isBranch f) |> List.map (fun (f, size) -> (getItemFromNode f, size))

    let sizesSorted = dirsWithAllChildren |> List.map (fun (item, children) -> (item, children |> List.sumBy (fun item -> item.size)))
                        |> List.map (fun (_, size) -> size) |> List.sort
    let total = sizesSorted |> List.max
    let overshoot = total - maxForExistingStructure

    let smallestBigNuff = sizesSorted |> List.find (fun size -> size >= overshoot)

    smallestBigNuff
```
Result (in `66`ms): `4473403`
## [Day 8 - Treetop Tree House](https://adventofcode.com/2022/day/8)
[Source](/AofC_2022/Days/D8.fs) | [Input](/AofC_2022/Days/D8.txt)  
### part1
```FSharp
let part1 input =
    let matrix = { data = Parsing.parseRows input parseRow }

    let getMaxAndVisible pt step = lineOfSight matrix pt step 
                                |> Seq.fold (fun (currentMax, lst) curr -> 
                                    let height = matrix.getAt curr
                                    if height > currentMax then (height, [curr] |> List.append lst) else (currentMax, lst))
                                    (0, [])

    let getVisible pt step = snd (getMaxAndVisible pt step)

    let viewpoints numSteps otherside =
        [1..numSteps] |> List.map (fun x -> 
            [ (0, [0;1]); (otherside, [0;-1])] |> List.map (fun (y, dir) -> ([x;y], dir))
        ) |> List.reduce List.append
    
    let forX = viewpoints (matrix.size.x - 2) (matrix.size.y-1)
    let forY = viewpoints (matrix.size.y - 2) (matrix.size.x-1) |> List.map (fun (pt, dir) -> (pt |> List.rev, dir |> List.rev))

    let lstToPt (lst: int list) = { x = lst[0]; y = lst[1]; }
    let allViewpoints = forX |> List.append forY |> List.map (fun (pt, dir) -> (lstToPt pt, lstToPt dir))

    let visibleFromViewpoints = allViewpoints |> List.map (fun (pt, step) -> getVisible pt step) |> List.reduce List.append |> List.distinct

    let exceptEdges = visibleFromViewpoints |> List.filter (fun pt -> pt.x > 0 && pt.y > 0 && pt.x < (matrix.size.x-1) && pt.y < (matrix.size.y-1))

    let result = exceptEdges.Length + matrix.size.x * 2 + matrix.size.y * 2 - 4
    result
```
Result (in `32`ms): `1803`
### part2
```FSharp
let part2 input =
    let matrix = { data = Parsing.parseRows input parseRow }
    let directions = [{x=1;y=0}; {x= -1;y=0}; {x=0;y=1}; {x=0;y= -1}]
    let viewpoints = [0..matrix.size.x-1] |> List.map (fun x -> [0..matrix.size.y-1] |> List.map (fun y -> {x=x;y=y;})) |> List.reduce List.append

    let folder threshold (currentMax, lst) curr = 
        let newMax = max (matrix.getAt curr) currentMax
        if newMax >= threshold then 
            if currentMax < 99 then (99, addToList lst curr)
            else (currentMax,lst)
        else
            (newMax, addToList lst curr)

    let getClearingDistance pt direction threshold = lineOfSight matrix pt direction |> Seq.fold (folder threshold) (0, [])
    let getClearingDistanceX pt direction = snd (getClearingDistance (add pt direction) direction (matrix.getAt pt))
    
    let getViewLengths pt = directions |> List.map (fun dir -> getClearingDistanceX pt dir) |> List.map (fun f -> f.Length)

    let visibleFromViewpoints = viewpoints |> List.map (fun pt -> (getViewLengths pt))
    let mul lst = lst |> List.reduce (fun a b -> a * b)
    let scores = visibleFromViewpoints |> List.map mul

    let result = scores |> List.max
    result
```
Result (in `559`ms): `268912`
## [Day 9 - Rope Bridge](https://adventofcode.com/2022/day/9)
[Source](/AofC_2022/Days/D9.fs) | [Input](/AofC_2022/Days/D9.txt)  
### part1
```FSharp
let part1 input =
    let instructions = Parsing.parseRows input parseRow

    let allHeadMoves =
        let step lst (pt, len) = ([|1..len|] |> Array.map (fun f -> pt)) |> Array.append lst 
        instructions |> Array.fold step [||]

    let trail = getPath allHeadMoves Vector2D.empty

    let allTails = trail |> Array.map (fun f -> f.tail)
    let result = allTails |> Array.distinct |> Array.length

    result
```
Result (in `163`ms): `6314`
### part2
```FSharp
let part2 input =
    let instructions = Parsing.parseRows input parseRow

    let headMovesToTailPositions headMoves =
        let trail = getPath headMoves Vector2D.empty
        trail |> Array.map (fun f -> f.tail) |> Array.tail // never any movement first step

    let absoluteToRelative (lst: Vector2D array) =
        lst |> Array.windowed 2 |> Array.map (fun x -> x[1].sub x[0])

    let relativeToAbsolute (lst: Vector2D array) =
        lst |> Array.fold (fun agg curr -> 
            let newPos = curr.add (agg |> Array.last)
            [|newPos|] |> Array.append agg
            ) [|Vector2D.empty|]

    let allHeadMoves =
        let step lst (pt, len) = ([|1..len|] |> Array.map (fun f -> pt)) |> Array.append lst 
        instructions |> Array.fold step [||]

    let finalMoves = [|1..9|] |> Array.fold (fun agg _ -> headMovesToTailPositions agg |> absoluteToRelative) allHeadMoves

    let absolute = relativeToAbsolute finalMoves
    //let rect = visualize absolute

    let result = absolute |> Array.distinct |> Array.length

    result
```
Result (in `1364`ms): `2504`
