# AofC_2022

Learning F# by doing [AdventOfCode 2022](https://adventofcode.com/2022)

Previous:
* [2021](https://github.com/JWMB/AofC_2021)


##Autogenerated##
## [Day 1 - Calorie Counting](https://adventofcode.com/2022/day/1)
[Source](/AofC_2022/Days/D1.fs) | [Input](/AofC_2022/Days/D1.txt)  
### part1
```FSharp
let part1 input =
    let result = Array.max (sums input)
    result
```

Result (in `3`ms): `71934`
### part2
```FSharp
let part2 input =
    let sorted = (sums input) |> Array.sortDescending
    let result = sorted |> Array.take 3 |> Array.sum
    result
```

Result (in `4`ms): `211447`
## [Day 2 - Rock Paper Scissors](https://adventofcode.com/2022/day/2)
[Source](/AofC_2022/Days/D2.fs) | [Input](/AofC_2022/Days/D2.txt)  
### part1
```FSharp
let part1 input =
    let rows = Parsing.parseRows input parseRow
    let results = rows |> Array.map (fun f -> getOutcome f[0] f[1])
    let sum = results |> Array.sum
    sum
```

Result (in `10`ms): `10624`
### part2
```FSharp
let part2 input =
    let rows = Parsing.parseRows input parseRow
    let results = rows |> Array.map (fun f -> (chooseItem f[0] (f[1] - 1)) + 1 + getPoints (f[1] - 1))
    let sum = results |> Array.sum
    sum
```

Result (in `15`ms): `14060`
## [Day 3 - Rucksack Reorganization](https://adventofcode.com/2022/day/3)
[Source](/AofC_2022/Days/D3.fs) | [Input](/AofC_2022/Days/D3.txt)  
### part1
```FSharp
let part1 input =
    let rucksacks = Parsing.parseRows input parseRow
    let compartmentalized = rucksacks |> Array.map (fun f -> f |> Array.splitAt (f.Length / 2))
    let samePer = compartmentalized |> Array.map (fun (a, b) -> [| a; b |] |> intersectMany)
    let sum = samePer |> flatten |> Array.sum
    sum
```

Result (in `29`ms): `7997`
### part2
```FSharp
let part2 input =
    let rucksacks = Parsing.parseRows input parseRow
    let numGroups = rucksacks.Length / 3
    let groups = rucksacks |> Array.splitInto numGroups
    let samePer = groups |> Array.map intersectMany
    let sum = samePer |> flatten |> Array.sum
    sum
```

Result (in `4`ms): `2545`
## [Day 4 - Camp Cleanup](https://adventofcode.com/2022/day/4)
[Source](/AofC_2022/Days/D4.fs) | [Input](/AofC_2022/Days/D4.txt)  
### part1
```FSharp
let part1 input =
    let pairs = Parsing.parseRows input parseRow
    let numWithCompleteOverlap = pairs |> Array.filter (fun pair -> isRangeWithin pair[0] pair[1] || isRangeWithin pair[1] pair[0]) |> Array.length
    numWithCompleteOverlap
```

Result (in `8`ms): `450`
### part2
```FSharp
let part2 input =
    let pairs = Parsing.parseRows input parseRow
    let numWithPartialOverlap = pairs |> Array.filter (fun pair -> isRangeOverlap pair[0] pair[1]) |> Array.length
    numWithPartialOverlap
```

Result (in `4`ms): `837`
## [Day 5 - Supply Stacks](https://adventofcode.com/2022/day/5)
[Source](/AofC_2022/Days/D5.fs) | [Input](/AofC_2022/Days/D5.txt)  
### part1
```FSharp
let part1 input =
    let data = ParsedInput.Parse input

    let reverseLift = true
    let modifiedStacks = data.Instructions |> aggregate Array.fold (Instruction.Execute reverseLift) data.Stacks

    //let allStates = data.Instructions |> aggregate Seq.scan (Instruction.Execute reverseLift) data.Stacks
    //visualize "Days/D5part1.gif" allStates

    let result = modifiedStacks |> Array.map (fun f -> f[0]) |> Array.map string |> String.concat ""
    result
```
![visualization](/AofC_2022/Days/D5part1.gif)  
Result (in `19`ms): `SBPQRSCDF`
### part2
```FSharp
let part2 input =
    let data = ParsedInput.Parse input

    let reverseLift = false
    let modifiedStacks = data.Instructions |> aggregate Array.fold (Instruction.Execute reverseLift) data.Stacks
    
    //let allStates = data.Instructions |> aggregate Seq.scan (Instruction.Execute reverseLift) data.Stacks
    //visualize "Days/D5part2.gif" allStates

    let result = modifiedStacks |> Array.map (fun f -> f[0]) |> Array.map string |> String.concat ""
    result
```
![visualization](/AofC_2022/Days/D5part2.gif)  
Result (in `5`ms): `RGLVRCQSB`
## [Day 6 - Tuning Trouble](https://adventofcode.com/2022/day/6)
[Source](/AofC_2022/Days/D6.fs) | [Input](/AofC_2022/Days/D6.txt)  
### part1
```FSharp
let part1 input =
    let markerLength = 4

    let x = Parsing.cleanWithTrimEmptyLines input
            |> Seq.indexed
            |> Seq.fold (findFirstNonRepeatingStringOfLength markerLength) (0, "")

    let result = getMarkerEndIndex x markerLength
    result
```

Result (in `15`ms): `1544`
### part2
```FSharp
let part2 input =
    let markerLength = 14
    let x = Parsing.cleanWithTrimEmptyLines input
            |> Seq.indexed
            |> Seq.fold (findFirstNonRepeatingStringOfLength markerLength) (0, "")

    let result = getMarkerEndIndex x markerLength
    result
```

Result (in `2`ms): `2145`
## [Day 7 - No Space Left On Device](https://adventofcode.com/2022/day/7)
[Source](/AofC_2022/Days/D7.fs) | [Input](/AofC_2022/Days/D7.txt)  
### part1
```FSharp
let part1 input =
    let hierarchy = getHierarchy input

    let dirsWithAllChildren = flattenChildren hierarchy |> Seq.toList |> List.filter (fun (f, _) -> isBranch f) |> List.map (fun (f, size) -> (getItemFromNode f, size))

    let sizes = dirsWithAllChildren |> List.map (fun (f, children) -> (f, children |> List.sumBy (fun f -> f.size)))
                    |> List.map (fun (_, size) -> size)
    let sum = sizes |> List.filter (fun size -> size <= 100000) |> List.sum
    sum
```

Result (in `146`ms): `2061777`
### part2
```FSharp
let part2 input =
    let maxSpace = 70000000
    let needed = 30000000
    let maxForExistingStructure = maxSpace - needed

    let hierarchy = getHierarchy input

    let dirsWithAllChildren = flattenChildren hierarchy |> Seq.toList |> List.filter (fun (f, _) -> isBranch f) |> List.map (fun (f, size) -> (getItemFromNode f, size))

    let sizesSorted = dirsWithAllChildren |> List.map (fun (item, children) -> (item, children |> List.sumBy (fun item -> item.size)))
                        |> List.map (fun (_, size) -> size) |> List.sort
    let total = sizesSorted |> List.max
    let overshoot = total - maxForExistingStructure

    let smallestBigNuff = sizesSorted |> List.find (fun size -> size >= overshoot)

    smallestBigNuff
```

Result (in `67`ms): `4473403`
## [Day 8 - Treetop Tree House](https://adventofcode.com/2022/day/8)
[Source](/AofC_2022/Days/D8.fs) | [Input](/AofC_2022/Days/D8.txt)  
### part1
```FSharp
let part1 input =
    let matrix = { data = Parsing.parseRows input parseRow }

    let getMaxAndVisible pt step = lineOfSight matrix pt step 
                                |> Seq.fold (fun (currentMax, lst) curr -> 
                                    let height = matrix.getAt curr
                                    if height > currentMax then (height, [curr] |> List.append lst) else (currentMax, lst))
                                    (0, [])

    let getVisible pt step = snd (getMaxAndVisible pt step)

    let viewpoints numSteps otherside =
        [1..numSteps] |> List.map (fun x -> 
            [ (0, [0;1]); (otherside, [0;-1])] |> List.map (fun (y, dir) -> ([x;y], dir))
        ) |> List.reduce List.append
    
    let forX = viewpoints (matrix.size.x - 2) (matrix.size.y-1)
    let forY = viewpoints (matrix.size.y - 2) (matrix.size.x-1) |> List.map (fun (pt, dir) -> (pt |> List.rev, dir |> List.rev))

    let lstToPt (lst: int list) = { x = lst[0]; y = lst[1]; }
    let allViewpoints = forX |> List.append forY |> List.map (fun (pt, dir) -> (lstToPt pt, lstToPt dir))

    let visibleFromViewpoints = allViewpoints |> List.map (fun (pt, step) -> getVisible pt step) |> List.reduce List.append |> List.distinct

    let exceptEdges = visibleFromViewpoints |> List.filter (fun pt -> pt.x > 0 && pt.y > 0 && pt.x < (matrix.size.x-1) && pt.y < (matrix.size.y-1))

    let result = exceptEdges.Length + matrix.size.x * 2 + matrix.size.y * 2 - 4
    result
```

Result (in `34`ms): `1803`
### part2
```FSharp
let part2 input =
    let matrix = { data = Parsing.parseRows input parseRow }
    let directions = [{x=1;y=0}; {x= -1;y=0}; {x=0;y=1}; {x=0;y= -1}]
    let viewpoints = [0..matrix.size.x-1] |> List.map (fun x -> [0..matrix.size.y-1] |> List.map (fun y -> {x=x;y=y;})) |> List.reduce List.append

    let folder threshold (currentMax, lst) curr = 
        let newMax = max (matrix.getAt curr) currentMax
        if newMax >= threshold then 
            if currentMax < 99 then (99, addToList lst curr)
            else (currentMax,lst)
        else
            (newMax, addToList lst curr)

    let getClearingDistance pt direction threshold = lineOfSight matrix pt direction |> Seq.fold (folder threshold) (0, [])
    let getClearingDistanceX (pt: Vector2D) direction = snd (getClearingDistance (pt.add direction) direction (matrix.getAt pt))
    
    let getViewLengths pt = directions |> List.map (fun dir -> getClearingDistanceX pt dir) |> List.map (fun f -> f.Length)

    let visibleFromViewpoints = viewpoints |> List.map (fun pt -> (getViewLengths pt))
    let mul lst = lst |> List.reduce (fun a b -> a * b)
    let scores = visibleFromViewpoints |> List.map mul

    let result = scores |> List.max
    result
```

Result (in `491`ms): `268912`
## [Day 9 - Rope Bridge](https://adventofcode.com/2022/day/9)
[Source](/AofC_2022/Days/D9.fs) | [Input](/AofC_2022/Days/D9.txt)  
### part1
```FSharp
let part1 input =
    let headPath = instructionsToHeadPath (Parsing.parseRows input parseRow)
    let tailPath = getTailPath headPath Vector2D.empty
    let result = tailPath |> Array.distinct |> Array.length
    result
```

Result (in `368`ms): `6314`
### part2
```FSharp
let part2 input =
    let headPath = instructionsToHeadPath (Parsing.parseRows input parseRow)

    let headPathToTailPath headPositions =
        let tailPath = getTailPath headPositions Vector2D.empty
        tailPath |> Array.tail // never any movement first step

    // scan instead of fold here?
    let allTailPaths = [|1..9|] |> Array.fold (fun agg _ -> 
                            let tailPath = headPathToTailPath (Array.last agg)
                            [|tailPath|] |> Array.append agg
                            ) [|headPath|]

    // visualize allTailPaths

    let result = allTailPaths |> Array.last |> Array.distinct |> Array.length
    result
```
![visualization](/AofC_2022/Days/D9part2.gif)  
Result (in `1815`ms): `2504`
## [Day 10 - Cathode-Ray Tube](https://adventofcode.com/2022/day/10)
[Source](/AofC_2022/Days/D10.fs) | [Input](/AofC_2022/Days/D10.txt)  
### part1
```FSharp
let part1 input =
    let rows = Parsing.parseRows input parseRow

    let final = rows |> Seq.fold (fun (state, history) change ->
                let newState = { CycleNum = change.CycleNum + state.CycleNum ; X = change.X + state.X; }

                let remainder cycle = (cycle + 40 - 20) % 40

                if remainder state.CycleNum > remainder newState.CycleNum then
                    let stateToLog =
                        let overshoot = remainder newState.CycleNum
                        { CycleNum = newState.CycleNum - overshoot; X = state.X }
                    (newState, [|stateToLog|] |> Array.append history)
                else (newState, history)
                ) ({ CycleNum = 0; X = 1; }, [||])

    let result = (snd final) |> Array.map (fun f -> f.CycleNum * f.X) |> Array.sum

    result
```

Result (in `1`ms): `12540`
### part2
```FSharp
let part2 input =
    let rows = Parsing.parseRows input parseRow

    let sequenced = rows |> Seq.scan (fun (currState, _) change ->
                        let newState = { CycleNum = change.CycleNum ; X = change.X + currState.X; }
                        (newState, {1..newState.CycleNum} |> Seq.map (fun f -> currState.X))
                            ) ({ CycleNum = 0; X = 1; }, Seq.empty)

    let flattened = sequenced |> Seq.map (fun (_, seq) -> seq) |> Seq.reduce Seq.append |> Seq.toArray

    let renderRow arr = arr |> Array.indexed |> Array.map (fun (index, value) -> 
                                                    let diff = value - index
                                                    if abs diff <= 1 then "#" else "."
                                                    ) |> String.concat ""
    let result = flattened |> Array.chunkBySize 40 |> Array.map renderRow |> String.concat "\n"
    result
```

Result (in `8`ms): 
```
####.####..##..####.####.#....#..#.####.
#....#....#..#....#.#....#....#..#.#....
###..###..#......#..###..#....####.###..
#....#....#.....#...#....#....#..#.#....
#....#....#..#.#....#....#....#..#.#....
#....####..##..####.####.####.#..#.####.
```
## [Day 11 - Monkey in the Middle](https://adventofcode.com/2022/day/11)
[Source](/AofC_2022/Days/D11.fs) | [Input](/AofC_2022/Days/D11.txt)  
### part1
```FSharp
let part1 input =
    let parsed = parseInput input
    let states = parsed |> Array.map (fun (state, _) -> state)
    let monkeys = parsed |> Array.map (fun (_, monkey) -> monkey)

    let numRounds = 20
    let postProcess v = v / 3L
    let final = run states monkeys postProcess numRounds

    topInspectionsProduct 2 final
```

Result (in `13`ms): `57348`
### part2
```FSharp
let part2 input =
    let parsed = parseInput input
    let states = parsed |> Array.map (fun (state, _) -> state)
    let monkeys = parsed |> Array.map (fun (_, monkey) -> monkey)

    let divisorProduct = monkeys |> Array.map (fun f -> f.Divisor) |> Array.reduce (fun a b -> a * b)

    let numRounds = 10000
    let postProcess v = v % divisorProduct
    let final = run states monkeys postProcess numRounds

    let result = topInspectionsProduct 2 final
    result
```

Result (in `298`ms): `14106266886`
## [Day 12 - Hill Climbing Algorithm](https://adventofcode.com/2022/day/12)
[Source](/AofC_2022/Days/D12.fs) | [Input](/AofC_2022/Days/D12.txt)  
### part1
```FSharp
let part1 input =
    let (startPos, finalPos, grid) = parse input        

    let paths = findPaths grid startPos (fun p -> p = finalPos) (fun nextVal currentVal -> nextVal <= (currentVal + 1))
    let shortest = paths |> Seq.sortBy (fun f -> f.Length) |> Seq.head

    let result = shortest.Length - 1
    result
```

Result (in `4550`ms): `339`
### part2
```FSharp
let part2 input =
    let (startPos, finalPos, grid) = parse input  

    let findChar (rows: char array array) char = 
        rows |> Array.indexed |> Array.map (fun (y, row) -> 
            let found = row |> Array.indexed |> Array.filter (fun (_, f) -> f = char) |> Array.map (fun (x, _) -> { x = x; y = y; })
            found
            ) |> Array.reduce Array.append

    let startPositions = findChar (Parsing.parseRows input parseRow) 'a' |> Array.append [|startPos|]

    let excludeInnerPatches =
        // performance - get continuous areas of 'a', change all internal except edges to very high value (= don't try that path)
        let surrounded = startPositions 
                            |> Array.filter (fun p -> 
                                let hasNonSameNeighbor = grid.getNeighbors p |> Array.map (fun n -> startPositions |> Array.contains n) |> Array.contains false
                                if hasNonSameNeighbor then false else true
                                )

        let startPositionsEdges = startPositions |> Array.except surrounded
        for pt in surrounded do
            grid.Data[pt.y][pt.x] <- 9999
        startPositionsEdges

    let startPositions = excludeInnerPatches

    //let s = grid.toString

    let paths = findPaths grid finalPos (fun p -> startPositions |> Array.contains p) (fun nextVal currentVal -> nextVal >= currentVal - 1)
    let shortest = paths |> Seq.sortBy (fun f -> f.Length) |> Seq.head

    let result = shortest.Length - 1

    result
```

Result (in `11588`ms): `332`
## [Day 13 - Distress Signal](https://adventofcode.com/2022/day/13)
[Source](/AofC_2022/Days/D13.fs) | [Input](/AofC_2022/Days/D13.txt)  
### part1
```FSharp
let part1 input =
    let pairs = input |> Parsing.cleanWithTrimEmptyLines |> RxCurry.splitTrimNoEmpty @"\n\n" |> Array.map parseSection
    //let oppo = pairs |> Array.map (fun (a, _) -> toString a)
    //let oppo = pairs |> Array.map (fun (a, _) -> getAsNumberSequence (Child a) |> Seq.toArray)

    let indicesOfCorrect = pairs |> Array.map isFirstLargest |> Array.indexed |> Array.filter (fun (_, v) -> v) |> Array.map (fun (i, _) -> i)

    let result = indicesOfCorrect |> Array.map (fun f -> f + 1) |> Array.sum
    result
```

Result (in `15`ms): `6395`
### part2
```FSharp
let part2 input =
    let dividersInput = """
[[2]]
[[6]]
"""
    let added = [|input; dividersInput|] |> String.concat ""
    let full = (added |> Parsing.cleanWithTrimEmptyLines).Replace("\n\n", "\n") //|> RxCurry.splitTrimNoEmpty @"\n\n" |> Array.map parseSection
    let all = full |> RxCurry.splitTrimNoEmpty "\n" |> Array.map parseRow

    //let indicesOfCorrect = pairs |> Array.map isFirstLargest |> Array.indexed |> Array.filter (fun (_, v) -> v) |> Array.map (fun (i, _) -> i)

    let sorted = all |> Array.sortWith (fun a b ->
                            let firstIsLargest = isFirstLargest (a, b) 
                            if firstIsLargest then 1 else -1) |> Array.rev

    let dividers = dividersInput |> RxCurry.splitTrimNoEmpty "\n" |> Array.map parseRow

    let findIndex value = sorted |> Array.findIndex (fun f -> f = value)
    let indices = dividers |> Array.map findIndex

    let result = indices |> Array.map (fun f -> f + 1) |> Array.reduce (fun a b -> a * b)
    result
```

Result (in `21`ms): `24921`
## [Day 14 - Regolith Reservoir](https://adventofcode.com/2022/day/14)
[Source](/AofC_2022/Days/D14.fs) | [Input](/AofC_2022/Days/D14.txt)  
### part1
```FSharp
let part1 input =
    let linePoints = Parsing.parseRows input parseRow |> Array.reduce Array.append

    let grid = Grid.create linePoints { x = 500; y = 0; }

    let rec untilOutsize cnt =
        let foundRestingPlace = fall grid grid.Source
        if foundRestingPlace.IsNone then cnt
        else untilOutsize (cnt + 1)

    let numDrops = untilOutsize 0
    numDrops
```

Result (in `939`ms): `795`
### part2
```FSharp
let part2 input =
    let linePoints = Parsing.parseRows input parseRow |> Array.reduce Array.append
    let grid = Grid.create linePoints { x = 500; y = 0; }

    let newHeight = grid.Rect.bottom + 2 // for bedrock

    // expand grid so that width = height and source is in middle of x axis
    let newWidth = 2 * newHeight //bah, just make it big enough
    let newLeft = min (grid.Source.x - newWidth) grid.Rect.left
    let newRight = max (grid.Source.x + newWidth) grid.Rect.right

    let bedrock = [|newLeft..newRight|] |> Array.map(fun x -> { x = x; y = newHeight; })
    
    let grid = Grid.create (grid.Rocks |> Array.append bedrock) grid.Source

    //let before = grid.render

    let rec untilOutsize cnt =
        let foundRestingPlace = fall grid grid.Source
        if foundRestingPlace.IsNone then cnt
        else untilOutsize (cnt + 1)
        
    let numDrops = untilOutsize 0

    //let after = grid.render

    numDrops
```

Result (in `13861`ms): `30214`
